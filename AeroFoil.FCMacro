#!/usr/bin/env python
# -*- coding: utf-8 -*-



"""

##########################################################################################
#####				L I C E N S E					     #####
##########################################################################################

  GNU LESSER GENERAL PUBLIC LICENSE
  Version 2.1, February 1999

  Copyright (C) 1991, 1999 Free Software Foundation, Inc.
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.

  [This is the first released version of the Lesser GPL. It also counts
  as the successor of the GNU Library Public License, version 2, hence
  the version number 2.1.]

  'AeroFoil' is a FreeCAD macro. AeroFoil creates airfoil curves and faces 
  using pre-defined models, algebraic functions, and DAT or CSV Files.

  Copyright (C) 2021  Melwyn Francis Carlo

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this library; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

  Contact Information :-
  Email :  carlo.melwyn@outlook.com
  FreeCAD UserTalk :  http://www.freecadweb.org/wiki/index.php?title=User:Melwyncarlo

##########################################################################################
#####				L I C E N S E					     #####
##########################################################################################



  To use this macro, the steps to be followed are simple and straightforward :
  follow the instructions in the respective dialog boxes, fill in the relevant inputs, 
  and navigate accordingly. In case of error or warning, you will automatically be 
  notified the same. In case you are notified to report an unexpected error, 
  communicate the error by mentioning the FreeCAD version, tracing the steps 
  taken, and mentioning whether (and how much) or not any ouput was generated.

  Note (1)	Performing the macro operation with custom points and refinement 
		produces no visible changes.
  Note (2)	The AeroFoil object properties are only visible on the FreeCAD 
		software version 0.19. On older versions, you will be shown 
		a warning on the console.



  The AeroFoil macro was developed and tested on a platform containing the 
  following system and FreeCAD software specifications : 

  - OS			: Ubuntu 18.04.5 LTS (LXDE/Lubuntu)
  - Word size of OS	: 64-bit
  - Word size of FreeCAD: 64-bit
  - Version		: 0.19
  - Build type		: Release
  - Branch		: unknown
  - Hash		: 32200b604d421c4dad527fe587a7d047cf953b4f
  - Python version	: 3.6.9
  - Qt version		: 5.9.5
  - Coin version	: 4.0.0a
  - OCC version		: 7.3.0
  - Locale		: English/UnitedKingdom (en_GB)

"""



__Title__ = "AeroFoil"
__Author__ = "Melwyncarlo"
__Version__ = "1.0.0"
__Date__ = "2021-02-26"
__Comment__ = "AeroFoil creates airfoil curves and faces using pre-defined models, algebraic functions, and DAT or CSV Files"
__Web__ = "https://github.com/melwyncarlo/AeroFoil"
__Wiki__ = "http://www.freecadweb.org/wiki/index.php?title=Macro_AeroFoil"
__Icon__ = "AeroFoil_UI_Files/AeroFoil.png"
__Help__ = "Click on the AeroFoil button/macro, and follow the instructions in the subsequent dialog boxes."
__Status__ = "stable"
__Requires__ = "Freecad >= v0.17"
__Communication__ = "https://github.com/melwyncarlo/AeroFoil/issues"
__Files__ = "AeroFoil_UI_Files/AeroFoil_Dialog_1.ui, AeroFoil_UI_Files/AeroFoil_Dialog_2a.ui, AeroFoil_UI_Files/AeroFoil_Dialog_2b.ui, \
AeroFoil_UI_Files/AeroFoil_Dialog_2c.ui, AeroFoil_UI_Files/AeroFoil_Dialog_2d.ui, AeroFoil_UI_Files/AeroFoil_Dialog_2d1a.ui, \
AeroFoil_UI_Files/AeroFoil_Dialog_2d1b.ui, AeroFoil_UI_Files/AeroFoil_Dialog_2cd2.ui, AeroFoil_UI_Files/AeroFoil_Dialog_3.ui, \
AeroFoil_UI_Files/AeroFoil_Math_Functions_Box.ui, AeroFoil_UI_Files/AeroFoil_mfb_img.gif"



# Library Imports
# ------------------------------------------------------------------------------------------------

import FreeCAD as App
import FreeCADGui, Part, Draft
from PySide2.QtWidgets import (
    QPushButton,
    QLineEdit,
    QComboBox,
    QRadioButton,
    QCheckBox,
    QSpinBox,
    QDoubleSpinBox,
    QLabel,
    QProgressBar,
)
import PySide
from PySide import QtGui, QtCore
from PySide.QtGui import *
from PySide.QtCore import *
from pathlib import Path
import time, math, csv, re



###########################################################################
###---------------------------------------------------------------------###
### 		AEROFOIL MACRO CALLS - Top (check Bottom)		###
###---------------------------------------------------------------------###
									###
def AeroFoil_generate(obj):						###
    n_ = (obj.multi * (obj.multiParam - 1)) + 1				###
    AeroFoil_object = AeroFoil(obj)					###
    if AeroFoil_object.create():					###
        AeroFoil_object.characterize()					###
    else:								###
        return False							###
    AeroFoil_object.copy(n_)						###
    return True								###
									###
###---------------------------------------------------------------------###
### 		AEROFOIL MACRO CALLS - Top (check Bottom)		###
###---------------------------------------------------------------------###
###########################################################################



# Constant Variables
# ------------------------------------------------------------------------------------------------

MAX_REFINE_PARAM = 2
MAX_QUANTITY_PARAM = 5
MIN_DATA_POINTS = 10
NACA_NUMBER_OF_POINTS = 50
NACA_5_2ND_3RD_DIGITS = ["10", "20", "30", "40", "50", "21", "31", "41", "51"]
FUNCTIONSARRAY = [
    "+",
    "-",
    "*",
    "/",
    "^",
    "e",
    "pi",
    "ln(",
    "log(",
    "sqrt(",
    "sin(",
    "cos(",
    "tan(",
    "asin(",
    "acos(",
    "atan(",
    "x",
    "(",
    ")",
    ".",
]
UNITSCONVERSION = [0, 1, 10, 1000, 25.4, 304.8, 914.4]
MIN_CHORD_LENGTH_MM = 1
MD_ = App.getUserMacroDir(True) + "/AeroFoil_UI_Files/AeroFoil_"



# Global Variables
# ------------------------------------------------------------------------------------------------

# Variables Pertaining to the Entire Program
dialogIndex = [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]



# Main Function Class
# ------------------------------------------------------------------------------------------------

class AeroFoil:
    def __init__(self, obj):
        global UNITSCONVERSION
        self.profileName = generateName("AeroFoil")
        self.chord = obj.chordLength * UNITSCONVERSION[obj.chordUnits]
        self.designtype = [obj.workbench, obj.curveType]
        self.designclosed = obj.closed_
        self.points = []
        self.points.append(obj.pointsX)
        self.points.append(obj.pointsY)
        self.n_units = len(self.points[0])
        self.objRefData = [
            obj.airfoilType,
            obj.airfoil4DNumber,
            obj.airfoil5DNumber,
            obj.airfoilProfileType,
            obj.importFrom,
        ]
        self.designprogressbar = obj.progressBar_

    def copy(self, quantity_):
        if quantity_ != 1:
            refNum = int(re.findall(r"\d+", self.profileName)[0])
            FreeCADGui.Selection.clearSelection()
            FreeCADGui.Selection.addSelection(
                App.ActiveDocument.getObjectsByLabel(self.profileName)[0]
            )
            FreeCADGui.runCommand("Std_Copy")
            for i in range(quantity_ - 1):
                FreeCADGui.runCommand("Std_Paste")
                App.ActiveDocument.getObjectsByLabel(
                    "AeroFoil_" + str(refNum + i + 1).zfill(3)
                )[0].Label = "AeroFoil_" + str(refNum + i + 1)
                if self.designprogressbar.value() < 99:
                    self.designprogressbar.setValue(
                        round(75 + ((i / (4 * quantity_)) * 100))
                    )
        self.designprogressbar.setValue(100)
        time.sleep(1)

    def characterize(self):
        try:
            objRef = App.ActiveDocument.getObjectsByLabel(self.profileName)[0]
            objRef.addProperty("App::PropertyString", "AirfoilType", "", "", 1)
            objRef.addProperty("App::PropertyLength", "AirfoilChordLength", "", "", 1)
            objRef.addProperty("App::PropertyString", "DesignCurveType", "", "", 1)
            objRef.addProperty("App::PropertyInteger", "NumberOfPoints", "", "", 1)
            tempStr = ""
            if self.objRefData[0] == 1:
                tempStr = "NACA - " + self.objRefData[1]
            elif self.objRefData[0] == 2:
                tempStr = "NACA - " + self.objRefData[2]
            elif self.objRefData[0] == 3 and self.objRefData[3] == 1:
                tempStr = "Custom Curves (Symmetric)"
            elif self.objRefData[0] == 3 and self.objRefData[3] == 2:
                tempStr = "Custom Curves (Asymmetric)"
            elif self.objRefData[0] == 4 and self.objRefData[4] == 1:
                tempStr = "Custom Points (DAT)"
            elif self.objRefData[0] == 4 and self.objRefData[4] == 2:
                tempStr = "Custom Points (CSV)"
            objRef.AirfoilType = tempStr
            objRef.AirfoilChordLength = str(self.chord) + "mm"
            tempStr = ""
            if self.designtype[1] == 1:
                tempStr = "Polygon"
            elif self.designtype[1] == 2:
                tempStr = "BSpline"
            objRef.DesignCurveType = tempStr
            objRef.NumberOfPoints = self.n_units - 1
        except Exception:
            print(
                "\nCannot generate AeroFoil properties in FreeCAD version &#60;0.19 !\n"
            )
            FreeCAD.Console.PrintWarning(
                "\nCannot generate AeroFoil properties in FreeCAD version &#60;0.19 !\n"
            )

    def create(self):
        constraintIndex = 0
        # Generating Polygons and BSplines
        try:
            if self.designtype[0] == 2:
                App.activeDocument().addObject(
                    "Sketcher::SketchObject", self.profileName
                )
                App.ActiveDocument.getObject(
                    self.profileName
                ).Placement = App.Placement(
                    App.Vector(0.000000, 0.000000, 0.000000),
                    App.Rotation(-0.707107, 0.000000, 0.000000, -0.707107),
                )
                App.ActiveDocument.getObject(self.profileName).MapMode = "Deactivated"
                if self.designtype[1] == 1:
                    App.ActiveDocument.getObject(self.profileName).addGeometry(
                        Part.LineSegment(
                            App.Vector(self.points[0][0], self.points[1][0], 0),
                            App.Vector(self.points[0][1], self.points[1][1], 0),
                        ),
                        False,
                    )
                    n_ = len(self.points[0]) - 2
                    for i in range(1, len(self.points[0]) - 1):
                        App.ActiveDocument.getObject(self.profileName).addGeometry(
                            Part.LineSegment(
                                App.Vector(self.points[0][i], self.points[1][i], 0),
                                App.Vector(
                                    self.points[0][i + 1], self.points[1][i + 1], 0
                                ),
                            ),
                            False,
                        )
                        App.ActiveDocument.getObject(self.profileName).addConstraint(
                            Sketcher.Constraint("Coincident", i - 1, 2, i, 1)
                        )
                        if self.designprogressbar.value() < 62.5:
                            self.designprogressbar.setValue(
                                round(50 + ((i / (8 * n_)) * 100))
                            )
                    App.ActiveDocument.getObject(self.profileName).addConstraint(
                        Sketcher.Constraint(
                            "Coincident", len(self.points[0]) - 2, 2, 0, 1
                        )
                    )
                    for j in range(n_):
                        constraintIndex = App.ActiveDocument.getObject(
                            self.profileName
                        ).addConstraint(
                            Sketcher.Constraint(
                                "DistanceX", -1, 1, j, 2, self.points[0][j + 1]
                            )
                        )
                        App.ActiveDocument.getObject(self.profileName).setDatum(
                            constraintIndex,
                            App.Units.Quantity(str(self.points[0][j + 1]) + "mm"),
                        )
                        constraintIndex = App.ActiveDocument.getObject(
                            self.profileName
                        ).addConstraint(
                            Sketcher.Constraint(
                                "DistanceY", -1, 1, j, 2, self.points[1][j + 1]
                            )
                        )
                        App.ActiveDocument.getObject(self.profileName).setDatum(
                            constraintIndex,
                            App.Units.Quantity(str(self.points[1][j + 1]) + "mm"),
                        )
                        if self.designprogressbar.value() < 75:
                            self.designprogressbar.setValue(
                                round(62.5 + ((j / (8 * n_)) * 100))
                            )
                    constraintIndex = App.ActiveDocument.getObject(
                        self.profileName
                    ).addConstraint(
                        Sketcher.Constraint("DistanceX", -1, 1, 0, 1, self.points[0][0])
                    )
                    App.ActiveDocument.getObject(self.profileName).setDatum(
                        constraintIndex,
                        App.Units.Quantity(str(self.points[0][0]) + "mm"),
                    )
                    constraintIndex = App.ActiveDocument.getObject(
                        self.profileName
                    ).addConstraint(
                        Sketcher.Constraint("DistanceY", -1, 1, 0, 1, self.points[1][0])
                    )
                    App.ActiveDocument.getObject(self.profileName).setDatum(
                        constraintIndex,
                        App.Units.Quantity(str(self.points[1][0]) + "mm"),
                    )
                elif self.designtype[1] == 2:
                    points, conList = [], []
                    n_ = len(self.points[0])
                    App.ActiveDocument.getObject(self.profileName).addGeometry(
                        Part.Circle(
                            App.Vector(self.points[0][0], self.points[1][0], 0),
                            App.Vector(0, 0, 1),
                            10,
                        ),
                        True,
                    )
                    App.ActiveDocument.getObject(self.profileName).addGeometry(
                        Part.Circle(
                            App.Vector(self.points[0][1], self.points[1][1], 0),
                            App.Vector(0, 0, 1),
                            10,
                        ),
                        True,
                    )
                    App.ActiveDocument.getObject(self.profileName).addConstraint(
                        Sketcher.Constraint("Radius", 0, 1.000000)
                    )
                    App.ActiveDocument.getObject(self.profileName).addConstraint(
                        Sketcher.Constraint("Equal", 0, 1)
                    )
                    for h in range(2, n_):
                        App.ActiveDocument.getObject(self.profileName).addGeometry(
                            Part.Circle(
                                App.Vector(self.points[0][h], self.points[1][h], 0),
                                App.Vector(0, 0, 1),
                                10,
                            ),
                            True,
                        )
                        App.ActiveDocument.getObject(self.profileName).addConstraint(
                            Sketcher.Constraint("Equal", 0, h)
                        )
                        if self.designprogressbar.value() < 60:
                            self.designprogressbar.setValue(
                                round(50 + ((h / (10 * n_)) * 100))
                            )
                    for i in range(n_):
                        points.append(App.Vector(self.points[0][i], self.points[1][i]))
                        conList.append(
                            Sketcher.Constraint(
                                "InternalAlignment:Sketcher::BSplineControlPoint",
                                i,
                                3,
                                len(self.points[0]),
                                i,
                            )
                        )
                        if self.designprogressbar.value() < 70:
                            self.designprogressbar.setValue(
                                round(60 + ((i / (10 * n_)) * 100))
                            )
                    App.ActiveDocument.getObject(self.profileName).addGeometry(
                        Part.BSplineCurve(points, None, None, True, 3, None, False),
                        False,
                    )
                    App.ActiveDocument.getObject(self.profileName).addConstraint(
                        conList
                    )
                    App.ActiveDocument.getObject(
                        self.profileName
                    ).exposeInternalGeometry(len(self.points[0]))
                    for j in range(n_):
                        constraintIndex = App.ActiveDocument.getObject(
                            self.profileName
                        ).addConstraint(
                            Sketcher.Constraint(
                                "DistanceX", -1, 1, j, 3, self.points[0][j]
                            )
                        )
                        App.ActiveDocument.getObject(self.profileName).setDatum(
                            constraintIndex,
                            App.Units.Quantity(str(self.points[0][j]) + "mm"),
                        )
                        constraintIndex = App.ActiveDocument.getObject(
                            self.profileName
                        ).addConstraint(
                            Sketcher.Constraint(
                                "DistanceY", -1, 1, j, 3, self.points[1][j]
                            )
                        )
                        App.ActiveDocument.getObject(self.profileName).setDatum(
                            constraintIndex,
                            App.Units.Quantity(str(self.points[1][j]) + "mm"),
                        )
                        if self.designprogressbar.value() < 75:
                            self.designprogressbar.setValue(
                                round(70 + ((j / (20 * n_)) * 100))
                            )
            elif self.designtype[0] == 1:
                DWireOrBSpline_, pointsVector = 0, []
                n_ = len(self.points[0])
                for i in range(n_):
                    pointsVector.append(
                        FreeCAD.Vector(self.points[0][i], 0, self.points[1][i])
                    )
                    if self.designprogressbar.value() < 75:
                        self.designprogressbar.setValue(
                            round(50 + ((i / (4 * n_)) * 100))
                        )
                if self.designtype[1] == 1:
                    # if self.designclosed is determined by face=self.designclosed
                    DWireOrBSpline_ = Draft.makeWire(
                        pointsVector,
                        closed=True,
                        placement=None,
                        face=self.designclosed,
                        support=None,
                    )
                elif self.designtype[1] == 2:
                    # if self.designclosed is determined by face=self.designclosed
                    DWireOrBSpline_ = Draft.makeBSpline(
                        pointsVector,
                        closed=True,
                        placement=None,
                        face=self.designclosed,
                        support=None,
                    )
                App.activeDocument().recompute()
                shape_ = App.ActiveDocument.addObject("Part::Feature", self.profileName)
                shape_.Shape = DWireOrBSpline_.Shape
                App.ActiveDocument.removeObject(DWireOrBSpline_.Label)
        except Exception:
            # Unexpected Error Occurred while Processing
            try:
                App.ActiveDocument.removeObject(self.profileName)
            except Exception:
                pass
            App.activeDocument().recompute()
            return False
        App.activeDocument().recompute()
        FreeCADGui.activeDocument().activeView().viewFront()
        FreeCADGui.SendMsgToActiveView("ViewFit")
        return True



# Sub-main Function Class
# ------------------------------------------------------------------------------------------------

class AeroFoilDialog:
    def __init__(self):
        # Variables Pertaining to the Entire Program
        (
            self.canMirror,
            self.functionElements,
            self.functionElements_Pos,
            self.pointsX,
            self.pointsY,
        ) = (True, [], [], [], [])
        # Variables Pertaining to AeroFoil_Dialog_1
        self.airfoilType = 1
        # Variables Pertaining to AeroFoil_Dialog_2a
        self.airfoil4DNumber = ""
        # Variables Pertaining to AeroFoil_Dialog_2b
        self.airfoil5DNumber = ""
        # Variables Pertaining to AeroFoil_Dialog_2c
        self.airfoilProfileType, self.topCurveFunction, self.bottomCurveFunction = (
            1,
            "",
            "",
        )
        # Variables Pertaining to AeroFoil_Dialog_2d
        self.importFrom, self.mirroring = 1, False
        # Variables Pertaining to AeroFoil_Dialog_2d1a
        self.lineStart, self.lineEnd, self.decimalType = 0, 0, 1
        # Variables Pertaining to AeroFoil_Dialog_2d1b
        self.col1, self.col2, self.row1, self.row2 = 1, 2, 0, 0
        # Variables Pertaining to AeroFoil_Dialog_2cd2
        (
            self.loadSuccess,
            self.loadedFilePath,
            self.loadedFile,
            self.loadedFileContents,
        ) = (False, [""], "", [])
        # Variables Pertaining to AeroFoil_Dialog_3
        (
            self.refine,
            self.refineParam,
            self.multi,
            self.multiParam,
            self.closed_,
            self.workbench,
            self.curveType,
            self.maxRefineParamWarned,
            self.maxQuantityParamWarned,
            self.chordLength,
            self.chordUnits,
            self.progressBar_,
        ) = (False, 2, False, 2, False, 1, 1, False, False, 0, 1, 0)
        # Actual Functions begin here
        dialogIndex[0] = 1
        self.createDialogs()

    def d_(self, qcode, objStr):
        qkey = [
            0,
            QPushButton,
            QLineEdit,
            QComboBox,
            QRadioButton,
            QCheckBox,
            QSpinBox,
            QDoubleSpinBox,
            QLabel,
            QProgressBar,
        ]
        return self.dialog.findChild(qkey[qcode], objStr)

    def createDialogs(self):
        global MD_
        global dialogIndex
        if dialogIndex[0] == 1:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_1.ui")
            self.d_(1, "af_d1_close_button").clicked.connect(lambda: self.close_())
            self.d_(1, "af_d1_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(3, "af_d1_combo").setCurrentIndex(self.airfoilType - 1)
        elif dialogIndex[0] == 2:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2a.ui")
            self.d_(1, "af_d2a_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2a_back_button").clicked.connect(lambda: self.next_(-1))
            self.d_(2, "af_d2a_textbox").setText(self.airfoil4DNumber)
        elif dialogIndex[0] == 3:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2b.ui")
            self.d_(1, "af_d2b_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2b_back_button").clicked.connect(lambda: self.next_(-1))
            self.d_(2, "af_d2b_textbox").setText(self.airfoil5DNumber)
        elif dialogIndex[0] == 4:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2c.ui")
            self.d_(2, "af_d2c_textbox_1").setText(self.topCurveFunction)
            self.d_(2, "af_d2c_textbox_2").setText(self.bottomCurveFunction)
            self.d_(4, "af_d2c_radio_1").toggled.connect(
                lambda: self.af_d2c_radio_toggled()
            )
            if self.airfoilProfileType == 1:
                self.d_(4, "af_d2c_radio_1").setChecked(True)
            else:
                self.d_(4, "af_d2c_radio_2").setChecked(True)
            self.d_(1, "af_d2c_list_button").clicked.connect(
                lambda: self.functionsList()
            )
            self.d_(1, "af_d2c_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2c_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 5:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2d.ui")
            if self.importFrom == 1:
                self.d_(4, "af_d2d_radio_1").setChecked(True)
            else:
                self.d_(4, "af_d2d_radio_2").setChecked(True)
            if self.mirroring:
                self.d_(5, "af_d2d_checkbox").setChecked(True)
            else:
                self.d_(5, "af_d2d_checkbox").setChecked(False)
            self.d_(1, "af_d2d_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2d_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 6:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2d1a.ui")
            self.d_(6, "af_d2d1a_spinBox_1").setValue(self.lineStart)
            self.d_(6, "af_d2d1a_spinBox_2").setValue(self.lineEnd)
            if self.decimalType == 1:
                self.d_(4, "af_d2d1a_radio_1").setChecked(True)
            else:
                self.d_(4, "af_d2d1a_radio_2").setChecked(True)
            self.d_(1, "af_d2d1a_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2d1a_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 7:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2d1b.ui")
            self.d_(6, "af_d2d1b_spinBox_1").setValue(self.col1)
            self.d_(6, "af_d2d1b_spinBox_2").setValue(self.col2)
            self.d_(6, "af_d2d1b_spinBox_3").setValue(self.row1)
            self.d_(6, "af_d2d1b_spinBox_4").setValue(self.row2)
            if self.decimalType == 1:
                self.d_(4, "af_d2d1b_radio_1").setChecked(True)
            else:
                self.d_(4, "af_d2d1b_radio_2").setChecked(True)
            self.d_(1, "af_d2d1b_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2d1b_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 8:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_2cd2.ui")
            self.d_(2, "af_d2cd2_textbox").setText(self.loadedFilePath[0])
            if self.loadedFilePath[0] == "":
                self.loadSuccess = False
                self.d_(8, "af_d2cd2_label_2").setText("File Not Loaded")
                self.d_(8, "af_d2cd2_label_2").setStyleSheet("color: black;")
            else:
                if self.loadSuccess:
                    self.d_(8, "af_d2cd2_label_2").setText("File Loaded Successfully")
                    self.d_(8, "af_d2cd2_label_2").setStyleSheet("color: darkgreen;")
                else:
                    self.d_(8, "af_d2cd2_label_2").setText(
                        "File Loaded Un-successfully"
                    )
                    self.d_(8, "af_d2cd2_label_2").setStyleSheet("color: crimson;")
            self.d_(1, "af_d2cd2_load_button").clicked.connect(lambda: self.loadFile())
            self.d_(1, "af_d2cd2_next_button").clicked.connect(lambda: self.next_(1))
            self.d_(1, "af_d2cd2_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 9:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Dialog_3.ui")
            if self.refine:
                self.d_(6, "af_d3_spinbox_1").setValue(self.refineParam)
                self.d_(6, "af_d3_spinbox_1").setEnabled(True)
                self.d_(5, "af_d3_checkbox_1").setChecked(True)
            else:
                self.refineParam = 2
                self.d_(6, "af_d3_spinbox_1").setValue(2)
                self.d_(6, "af_d3_spinbox_1").setEnabled(False)
                self.d_(5, "af_d3_checkbox_1").setChecked(False)
            if self.multi:
                self.d_(6, "af_d3_spinbox_2").setValue(self.multiParam)
                self.d_(6, "af_d3_spinbox_2").setEnabled(True)
                self.d_(5, "af_d3_checkbox_2").setChecked(True)
            else:
                self.multiParam = 2
                self.d_(6, "af_d3_spinbox_2").setValue(2)
                self.d_(6, "af_d3_spinbox_2").setEnabled(False)
                self.d_(5, "af_d3_checkbox_2").setChecked(False)
            if self.closed_:
                self.d_(5, "af_d3_checkbox_3").setChecked(True)
                af_d3_checkbox_3_toggled(self)
            else:
                self.d_(5, "af_d3_checkbox_3").setChecked(False)
                self.d_(4, "af_d3_radio_1").setEnabled(True)
                self.d_(4, "af_d3_radio_2").setEnabled(True)
                if self.workbench == 1:
                    self.d_(4, "af_d3_radio_1").setChecked(True)
                    self.d_(4, "af_d3_radio_1a").setEnabled(True)
                    self.d_(4, "af_d3_radio_1b").setEnabled(True)
                    self.d_(4, "af_d3_radio_2a").setEnabled(False)
                    self.d_(4, "af_d3_radio_2b").setEnabled(False)
                    if self.curveType == 1:
                        self.d_(4, "af_d3_radio_1a").setChecked(True)
                    else:
                        self.d_(4, "af_d3_radio_1b").setChecked(True)
                else:
                    self.d_(4, "af_d3_radio_2").setChecked(True)
                    self.d_(4, "af_d3_radio_1a").setEnabled(False)
                    self.d_(4, "af_d3_radio_1b").setEnabled(False)
                    self.d_(4, "af_d3_radio_2a").setEnabled(True)
                    self.d_(4, "af_d3_radio_2b").setEnabled(True)
                    if self.curveType == 1:
                        self.d_(4, "af_d3_radio_2a").setChecked(True)
                    else:
                        self.d_(4, "af_d3_radio_2b").setChecked(True)
            self.progressBar_ = self.d_(9, "af_d3_progressbar")
            self.progressBar_.setEnabled(False)
            self.progressBar_.setValue(0)
            self.d_(7, "af_d3_spinbox_3").setValue(self.chordLength)
            self.d_(3, "af_d3_combobox").setCurrentIndex(self.chordUnits - 1)
            self.d_(4, "af_d3_radio_1").toggled.connect(
                lambda: self.af_d3_radio_toggled()
            )
            self.d_(5, "af_d3_checkbox_1").toggled.connect(
                lambda: self.af_d3_checkbox_1_toggled()
            )
            self.d_(5, "af_d3_checkbox_2").toggled.connect(
                lambda: self.af_d3_checkbox_2_toggled()
            )
            self.d_(5, "af_d3_checkbox_3").toggled.connect(
                lambda: self.af_d3_checkbox_3_toggled()
            )
            self.d_(6, "af_d3_spinbox_1").valueChanged.connect(
                lambda: self.af_d3_spinbox_1_toggled()
            )
            self.d_(6, "af_d3_spinbox_2").valueChanged.connect(
                lambda: self.af_d3_spinbox_2_toggled()
            )
            self.d_(1, "af_d3_create_button").clicked.connect(lambda: self.create_())
            self.d_(1, "af_d3_close_button").clicked.connect(lambda: self.close_())
            self.d_(1, "af_d3_back_button").clicked.connect(lambda: self.next_(-1))
        elif dialogIndex[0] == 10:
            self.dialog = FreeCADGui.PySideUic.loadUi(MD_ + "Math_Functions_Box.ui")
            self.d_(8, "af_mfb_label_6").setText("<img src=" + MD_ + "mfb_img.gif>")
            self.d_(1, "af_mfb_okay_button").clicked.connect(lambda: self.okay_())
        self.dialog.setWindowIcon(QtGui.QIcon(App.getUserMacroDir(True) + "/AeroFoil_UI_Files/AeroFoil.png"))
        self.dialog.exec_()

# Button Functions
# ----------------------------------------------------------------

    def close_(self):
        self.dialog.done(1)

    def next_(self, direction):
        global dialogIndex
        global MIN_DATA_POINTS
        if direction == -1:
            if dialogIndex[0] == 2:
                self.airfoil4DNumber = ""
            elif dialogIndex[0] == 3:
                self.airfoil5DNumber = ""
            elif dialogIndex[0] == 4:
                (
                    self.airfoilProfileType,
                    self.topCurveFunction,
                    self.bottomCurveFunction,
                ) = (1, "", "")
            elif dialogIndex[0] == 5:
                self.importFrom, self.mirroring = 1, False
            elif dialogIndex[0] == 6:
                self.lineStart, self.lineEnd, self.decimalType = 0, 0, 1
            elif dialogIndex[0] == 7:
                self.col1, self.col2, self.row1, self.row2 = 1, 2, 0, 0
            elif dialogIndex[0] == 8:
                (
                    self.loadedFilePath,
                    self.loadSuccess,
                    self.loadedFile,
                    self.loadedFileContents,
                ) = ([""], False, "", [])
            elif dialogIndex[0] == 9:
                (
                    self.refine,
                    self.refineParam,
                    self.multi,
                    self.multiParam,
                    self.closed_,
                    self.workbench,
                    self.curveType,
                    self.maxRefineParamWarned,
                    self.maxQuantityParamWarned,
                    self.chordLength,
                    self.chordUnits,
                ) = (False, 2, False, 2, False, 1, 1, False, False, 0, 1)
            dialogIndex[0] = dialogIndex[dialogIndex[0]]
        else:
            if dialogIndex[0] == 1:
                self.airfoilType = self.d_(3, "af_d1_combo").currentIndex() + 1
                if self.airfoilType == 1:
                    setDialogIndex(2)
                elif self.airfoilType == 2:
                    setDialogIndex(3)
                elif self.airfoilType == 3:
                    setDialogIndex(4)
                elif self.airfoilType == 4:
                    setDialogIndex(5)
            elif dialogIndex[0] == 2:
                self.airfoil4DNumber = self.d_(2, "af_d2a_textbox").text()
                if validateAirfoilNumber(self, 4):
                    setDialogIndex(9)
                else:
                    return
            elif dialogIndex[0] == 3:
                self.airfoil5DNumber = self.d_(2, "af_d2b_textbox").text()
                if validateAirfoilNumber(self, 5):
                    setDialogIndex(9)
                else:
                    return
            elif dialogIndex[0] == 4:
                self.topCurveFunction = self.d_(2, "af_d2c_textbox_1").text()
                self.bottomCurveFunction = self.d_(2, "af_d2c_textbox_2").text()
                if not self.d_(4, "af_d2c_radio_2").isChecked():
                    self.airfoilProfileType = 1
                    if validateFunction(self, 1):
                        setDialogIndex(9)
                    else:
                        return
                else:
                    self.airfoilProfileType = 2
                    if validateFunction(self, 2):
                        setDialogIndex(9)
                    else:
                        return
            elif dialogIndex[0] == 5:
                if self.d_(4, "af_d2d_radio_1").isChecked():
                    self.importFrom = 1
                    setDialogIndex(6)
                else:
                    self.importFrom = 2
                    setDialogIndex(7)
                if self.d_(5, "af_d2d_checkbox").isChecked():
                    self.mirroring = True
                else:
                    self.mirroring = False
            elif dialogIndex[0] == 6:
                tempVar1 = self.d_(6, "af_d2d1a_spinBox_1").value()
                tempVar2 = self.d_(6, "af_d2d1a_spinBox_2").value()
                tempVar3 = (
                    0 if tempVar1 == 0 or tempVar2 == 0 else tempVar2 - tempVar1 + 1
                )
                if tempVar3 == 0 or tempVar3 >= MIN_DATA_POINTS:
                    self.lineStart = self.d_(6, "af_d2d1a_spinBox_1").value()
                    self.lineEnd = self.d_(6, "af_d2d1a_spinBox_2").value()
                    if self.d_(4, "af_d2d1a_radio_1").isChecked():
                        self.decimalType = 1
                    else:
                        self.decimalType = 2
                    setDialogIndex(8)
                else:
                    setAlertBox(
                        "There must be a minimum of "
                        + str(MIN_DATA_POINTS)
                        + " selected file lines,\nthat is, pairs of data points !",
                        True,
                    )
                    return
            elif dialogIndex[0] == 7:
                tempVar = (
                    self.d_(6, "af_d2d1b_spinBox_4").value()
                    - self.d_(6, "af_d2d1b_spinBox_3").value()
                    + 1
                )
                if tempVar >= MIN_DATA_POINTS:
                    if (
                        self.d_(6, "af_d2d1b_spinBox_1").value()
                        == self.d_(6, "af_d2d1b_spinBox_2").value()
                    ):
                        self.col1 = self.d_(6, "af_d2d1b_spinBox_1").value()
                        self.col2 = self.d_(6, "af_d2d1b_spinBox_2").value()
                        self.row1 = self.d_(6, "af_d2d1b_spinBox_3").value()
                        self.row2 = self.d_(6, "af_d2d1b_spinBox_4").value()
                        if self.d_(4, "af_d2d1b_radio_1").isChecked():
                            self.decimalType = 1
                        else:
                            self.decimalType = 2
                        setDialogIndex(8)
                    else:
                        setAlertBox("The two file columns cannot be the same !", True)
                        return
                else:
                    setAlertBox(
                        "There must be a minimum of "
                        + str(MIN_DATA_POINTS)
                        + " selected file rows,\nthat is, pairs of data points !",
                        True,
                    )
                    return
            elif dialogIndex[0] == 8:
                if self.loadSuccess:
                    setDialogIndex(9)
                else:
                    setAlertBox(
                        "Cannot proceed further with an invalid/null file !", True
                    )
                    return
        self.close_()
        self.createDialogs()

    def okay_(self):
        global dialogIndex
        if dialogIndex[0] == 10:
            dialogIndex[0] = dialogIndex[10]
        elif dialogIndex[0] == 11:
            dialogIndex[0] = dialogIndex[11]
        self.close_()
        self.createDialogs()

    def loadFile(self):
        fileType = ""
        homeDirPath = str(Path.home())
        if self.importFrom == 1:
            fileType = "Text Files (*.dat)"
        elif self.importFrom == 2:
            fileType = "CSV Files (*.dat)"
        self.loadedFilePath = PySide.QtGui.QFileDialog.getOpenFileName(
            None, "Load 'Airfoil Points' Data File", homeDirPath, fileType
        )
        self.loadedFile = open(self.loadedFilePath[0], "r")
        if validateFile(self):
            self.loadSuccess = True
            if self.mirroring and not self.canMirror:
                setAlertBox(
                    "Airfoil profile is complete and cannot be mirrored.", False
                )
        else:
            self.loadSuccess = False
        self.close_()
        self.createDialogs()

    def create_(self):
        global UNITSCONVERSION
        global MIN_CHORD_LENGTH_MM
        if self.d_(5, "af_d3_checkbox_1").isChecked():
            self.refine = True
            self.refineParam = self.d_(6, "af_d3_spinbox_1").value()
        if self.d_(5, "af_d3_checkbox_2").isChecked():
            self.multi = True
            self.multiParam = self.d_(6, "af_d3_spinbox_2").value()
        if self.d_(5, "af_d3_checkbox_3").isChecked():
            self.closed_ = True
        if self.d_(4, "af_d3_radio_1").isChecked():
            self.workbench = 1
            if self.d_(4, "af_d3_radio_1a").isChecked():
                self.curveType = 1
            else:
                self.curveType = 2
        else:
            self.workbench = 2
            if self.d_(4, "af_d3_radio_2a").isChecked():
                self.curveType = 1
            else:
                self.curveType = 2
        self.chordLength = self.d_(7, "af_d3_spinbox_3").value()
        self.chordUnits = self.d_(3, "af_d3_combobox").currentIndex() + 1
        chordLength_conv = self.chordLength * UNITSCONVERSION[self.chordUnits]
        if chordLength_conv >= MIN_CHORD_LENGTH_MM:
            if prepareAeroFoil(self):
                if AeroFoil_generate(self):
                    self.close_()
                    alertBox = QtGui.QMessageBox(
                        QtGui.QMessageBox.Warning,
                        "AeroFoil",
                        "The process has been completed successfully !",
                    )
                    alertBox.setWindowModality(QtCore.Qt.ApplicationModal)
                    alertBox.exec_()
                    FreeCAD.Console.PrintMessage(
                        "\nThe AeroFoil process has been completed successfully !\n"
                    )
                    return
            setAlertBox(
                "Unexpected error has occurred while processing !\nPlease report.", True
            )
            self.progressBar_.setEnabled(False)
            self.progressBar_.setValue(0)
            FreeCAD.Console.PrintError(
                "\nUnexpected error has occurred while processing! Please report.\n"
            )
        else:
            setAlertBox(
                "Airfoil chord length cannot be less than "
                + str(MIN_CHORD_LENGTH_MM)
                + "mm !",
                True,
            )

# Other Design Functions
# ------------------------------------------------------------------------------------------

    def af_d2c_radio_toggled(self):
        if self.d_(4, "af_d2c_radio_1").isChecked():
            self.airfoilProfileType = 1
            self.d_(2, "af_d2c_textbox_2").setEnabled(False)
        else:
            self.airfoilProfileType = 2
            self.d_(2, "af_d2c_textbox_2").setEnabled(True)

    def af_d3_spinbox_1_toggled(self):
        global MAX_REFINE_PARAM
        if not self.maxRefineParamWarned:
            if self.d_(6, "af_d3_spinbox_1").value() > MAX_REFINE_PARAM:
                setAlertBox(
                    "Increase in refinement parameter leads to increase\nin time and memory usage.",
                    False,
                )
                self.maxRefineParamWarned = True

    def af_d3_spinbox_2_toggled(self):
        global MAX_QUANTITY_PARAM
        if not self.maxQuantityParamWarned:
            if self.d_(6, "af_d3_spinbox_2").value() > MAX_QUANTITY_PARAM:
                setAlertBox(
                    "Increase in quantity parameter leads to increase\nin time and memory usage.",
                    False,
                )
                self.maxQuantityParamWarned = True

    def af_d3_checkbox_1_toggled(self):
        self.d_(6, "af_d3_spinbox_1").setValue(2)
        if self.d_(5, "af_d3_checkbox_1").isChecked():
            self.d_(6, "af_d3_spinbox_1").setEnabled(True)
        else:
            self.d_(6, "af_d3_spinbox_1").setEnabled(False)

    def af_d3_checkbox_2_toggled(self):
        self.d_(6, "af_d3_spinbox_2").setValue(2)
        if self.d_(5, "af_d3_checkbox_2").isChecked():
            self.d_(6, "af_d3_spinbox_2").setEnabled(True)
        else:
            self.d_(6, "af_d3_spinbox_2").setEnabled(False)

    def af_d3_checkbox_3_toggled(self):
        self.d_(4, "af_d3_radio_1").setChecked(True)
        self.d_(4, "af_d3_radio_1a").setChecked(True)
        self.d_(4, "af_d3_radio_2a").setChecked(True)
        self.d_(4, "af_d3_radio_1a").setEnabled(True)
        self.d_(4, "af_d3_radio_1b").setEnabled(True)
        self.d_(4, "af_d3_radio_2a").setEnabled(False)
        self.d_(4, "af_d3_radio_2b").setEnabled(False)
        if self.d_(5, "af_d3_checkbox_3").isChecked():
            self.closed_ = True
            self.d_(4, "af_d3_radio_1").setEnabled(False)
            self.d_(4, "af_d3_radio_2").setEnabled(False)
        else:
            self.closed_ = False
            self.d_(4, "af_d3_radio_1").setEnabled(True)
            self.d_(4, "af_d3_radio_2").setEnabled(True)

    def af_d3_radio_toggled(self):
        self.d_(4, "af_d3_radio_1a").setChecked(True)
        self.d_(4, "af_d3_radio_2a").setChecked(True)
        if self.d_(4, "af_d3_radio_1").isChecked():
            self.d_(4, "af_d3_radio_1a").setEnabled(True)
            self.d_(4, "af_d3_radio_1b").setEnabled(True)
            self.d_(4, "af_d3_radio_2a").setEnabled(False)
            self.d_(4, "af_d3_radio_2b").setEnabled(False)
        else:
            self.d_(4, "af_d3_radio_1a").setEnabled(False)
            self.d_(4, "af_d3_radio_1b").setEnabled(False)
            self.d_(4, "af_d3_radio_2a").setEnabled(True)
            self.d_(4, "af_d3_radio_2b").setEnabled(True)

    def functionsList(self):
        self.topCurveFunction = self.d_(2, "af_d2c_textbox_1").text()
        self.bottomCurveFunction = self.d_(2, "af_d2c_textbox_2").text()
        setDialogIndex(10)
        self.close_()
        self.createDialogs()


def setDialogIndex(index):
    global dialogIndex
    dialogIndex[index] = dialogIndex[0]
    dialogIndex[0] = index


def setAlertBox(message, error):
    msgbox_ = 0
    if error:
        msgbox_ = QtGui.QMessageBox(
            QtGui.QMessageBox.Critical, "AeroFoil - Error Message", message
        )
    else:
        msgbox_ = QtGui.QMessageBox(
            QtGui.QMessageBox.Warning, "AeroFoil - Warning Message", message
        )
    msgbox_.setWindowModality(QtCore.Qt.ApplicationModal)
    msgbox_.exec_()



# Operating and Math Functions
# ------------------------------------------------------------------------------------------

def prepareAeroFoil(objRef):
    global UNITSCONVERSION
    global NACA_NUMBER_OF_POINTS
    chordLength_conv = objRef.chordLength * UNITSCONVERSION[objRef.chordUnits]
    # Enable Progress Bar
    objRef.progressBar_.setEnabled(True)
    objRef.progressBar_.setValue(0)
    # Generating and Furnishing Points
    if objRef.airfoilType == 1:
        naca4digit(objRef)
    elif objRef.airfoilType == 2:
        naca5digit(objRef)
    elif objRef.airfoilType == 3:
        xu_, yu_, xl_, yl_ = [], [], [], []
        n_ = (
            round(NACA_NUMBER_OF_POINTS / 2)
            * ((objRef.refine * (objRef.refineParam - 1)) + 1)
        ) + 1
        for points_i in range(n_):
            xu_.append((points_i / (n_ - 1)) * chordLength_conv)
            xl_.append((points_i / (n_ - 1)) * chordLength_conv)
            try:
                yu_.append(solveFx(objRef.topCurveFunction, xu_[-1]) * chordLength_conv)
                if objRef.airfoilProfileType == 1:
                    yl_.append(
                        -1
                        * solveFx(objRef.topCurveFunction, xu_[-1])
                        * chordLength_conv
                    )
                elif objRef.airfoilProfileType == 2:
                    yl_.append(
                        solveFx(objRef.bottomCurveFunction, xu_[-1]) * chordLength_conv
                    )
            except Exception:
                # Unexpected Error Occurred while Processing
                return False
            if objRef.progressBar_.value() < 50:
                objRef.progressBar_.setValue(round((points_i / (2 * n_)) * 100))
        xl_.reverse()
        yl_.reverse()
        objRef.pointsX, objRef.pointsY = xu_ + xl_, yu_ + yl_
    elif objRef.airfoilType == 4:
        i_start, i_end, count, tempVar, pointsInLine, pointsInLine_prev = (
            0,
            0,
            1,
            "",
            [],
            [],
        )
        i_start, i_end = (
            (objRef.lineStart, objRef.lineEnd)
            if objRef.importFrom == 1
            else (objRef.row1, objRef.row2)
        )
        n_ = (i_end - i_start) + 1
        i = 0
        for lineOrRow in objRef.loadedFileContents:
            if count >= i_start and count <= i_end:
                if objRef.decimalType == 1:
                    tempVar = lineOrRow
                elif objRef.decimalType == 2:
                    tempVar = (
                        lineOrRow.replace(",", ".")
                        if objRef.importFrom == 1
                        else [element_.replace(",", ".") for element_ in lineOrRow]
                    )
                pointsInLine = (
                    re.findall(r"[+-]?\d+(?:\.\d+)?", tempVar)
                    if objRef.importFrom == 1
                    else re.findall(
                        r"[+-]?\d+(?:\.\d+)?",
                        tempVar[col1 - 1] + " " + tempVar[col2 - 1],
                    )
                )
                if objRef.refine and count != i_start:
                    n_ = (
                        float(pointsInLine[0]) - float(pointsInLine_prev[0])
                    ) / objRef.refineParam
                    for i in range(objRef.refineParam - 1):
                        tempVar = float(pointsInLine_prev[0]) + n_
                        objRef.pointsX.append(tempVar * chordLength_conv)
                        objRef.pointsY.append(
                            interpolateNum(
                                float(pointsInLine_prev[0]),
                                float(pointsInLine_prev[1]),
                                float(pointsInLine[0]),
                                float(pointsInLine[1]),
                                tempVar,
                            )
                            * chordLength_conv
                        )
                pointsInLine_prev = pointsInLine
                objRef.pointsX.append(float(pointsInLine[0]) * chordLength_conv)
                objRef.pointsY.append(float(pointsInLine[1]) * chordLength_conv)
                if objRef.progressBar_.value() < 50:
                    objRef.progressBar_.setValue(
                        round(((count - i_start) / (2 * n_)) * 100)
                    )
                i += 1
            count += 1
    # Closing the Polygonal Curve
    if (
        objRef.pointsX[len(objRef.pointsX) - 1] != objRef.pointsX[0]
        or objRef.pointsY[len(objRef.pointsY) - 1] != objRef.pointsY[0]
    ):
        objRef.pointsX.append(objRef.pointsX[0])
        objRef.pointsY.append(objRef.pointsY[0])
    return True



def interpolateNum(x1_, y1_, x2_, y2_, x_):
    return y1_ + (((x_ - x1_) * (y2_ - y1_)) / (x2_ - x1_))



def generateName(inputName):
    nameIndex = 1
    while True:
        if not App.ActiveDocument.getObjectsByLabel(inputName + "_" + str(nameIndex)):
            return inputName + "_" + str(nameIndex)
        nameIndex += 1



def naca4digit(objRef):
    global UNITSCONVERSION
    global NACA_NUMBER_OF_POINTS
    chordLength_conv = objRef.chordLength * UNITSCONVERSION[objRef.chordUnits]
    xu_, yu_, xl_, yl_ = [], [], [], []
    yc_ = yt_ = theta_ = 0
    a0_, a1_, a2_, a3_, a4_ = 0.2969, -0.126, -0.3516, 0.2843, -0.1015
    m_, p_, t_ = (
        int(objRef.airfoil4DNumber[0]) / 100,
        int(objRef.airfoil4DNumber[1]) / 10,
        int(objRef.airfoil4DNumber[2] + objRef.airfoil4DNumber[3]) / 100,
    )
    n_ = (
        round(NACA_NUMBER_OF_POINTS / 2)
        * ((objRef.refine * (objRef.refineParam - 1)) + 1)
    ) + 1
    for i in range(n_):
        x_ = i / (n_ - 1)
        yt_ = (
            5
            * t_
            * (
                (a0_ * pow(x_, 0.5))
                + (a1_ * x_)
                + (a2_ * pow(x_, 2))
                + (a3_ * pow(x_, 3))
                + (a4_ * pow(x_, 4))
            )
        )
        if x_ < p_:
            yc_ = (m_ * ((2 * p_ * x_) - (x_ * x_))) / (p_ * p_)
            theta_ = math.degrees(math.atan((2 * m_ * (p_ - x_)) / (p_ * p_)))
        else:
            yc_ = (m_ * (1 - (2 * p_) + (2 * p_ * x_) - (x_ * x_))) / pow(1 - p_, 2)
            theta_ = math.degrees(math.atan((2 * m_ * (p_ - x_)) / pow(1 - p_, 2)))
        xu_.append((x_ - (yt_ * math.sin(math.radians(theta_)))) * chordLength_conv)
        yu_.append((yc_ + (yt_ * math.cos(math.radians(theta_)))) * chordLength_conv)
        xl_.append((x_ + (yt_ * math.sin(math.radians(theta_)))) * chordLength_conv)
        yl_.append((yc_ - (yt_ * math.cos(math.radians(theta_)))) * chordLength_conv)
        if objRef.progressBar_.value() < 50:
            objRef.progressBar_.setValue(round((i / (2 * n_)) * 100))
    xl_.reverse()
    yl_.reverse()
    objRef.pointsX, objRef.pointsY = xu_ + xl_, yu_ + yl_



def naca5digit(objRef):
    global UNITSCONVERSION
    global NACA_NUMBER_OF_POINTS
    chordLength_conv = objRef.chordLength * UNITSCONVERSION[objRef.chordUnits]
    xu_, yu_, xl_, yl_ = [], [], [], []
    yc_ = yt_ = theta_ = 0
    a0_, a1_, a2_, a3_, a4_ = 0.2969, -0.126, -0.3516, 0.2843, -0.1015
    R_ = [0.0580, 0.1260, 0.2025, 0.2900, 0.3910, 0.1300, 0.2170, 0.3180, 0.4410]
    K1_ = [361.400, 51.640, 15.957, 6.643, 3.230, 51.990, 15.793, 6.520, 3.191]
    K2K1_ = [0, 0, 0, 0, 0, 0.000764, 0.00677, 0.0303, 0.1355]
    index = int(objRef.airfoil5DNumber[1]) - 1 + (4 * int(objRef.airfoil5DNumber[2]))
    r_, k1_, k2k1_, t_ = (
        R_[index],
        K1_[index],
        K2K1_[index],
        int(objRef.airfoil5DNumber[3] + objRef.airfoil5DNumber[4]) / 100,
    )
    n_ = (
        round(NACA_NUMBER_OF_POINTS / 2)
        * ((objRef.refine * (objRef.refineParam - 1)) + 1)
    ) + 1
    for i in range(n_):
        x_ = i / (n_ - 1)
        yt_ = (
            5
            * t_
            * (
                (a0_ * pow(x_, 0.5))
                + (a1_ * x_)
                + (a2_ * pow(x_, 2))
                + (a3_ * pow(x_, 3))
                + (a4_ * pow(x_, 4))
            )
        )
        if int(objRef.airfoil5DNumber[2]) == 0:
            if x_ < r_:
                yc_ = (
                    k1_ * (pow(x_, 3) - (3 * r_ * x_ * x_) + (x_ * r_ * r_ * (3 - r_)))
                ) / 6
                theta_ = math.degrees(
                    math.atan(
                        (k1_ * ((3 * x_ * x_) - (6 * r_ * x_) + (r_ * r_ * (3 - r_))))
                        / 6
                    )
                )
            else:
                yc_ = (k1_ * pow(r_, 3) * (1 - x_)) / 6
                theta_ = math.degrees(math.atan(-(k1_ * pow(r_, 3)) / 6))
        elif int(objRef.airfoil5DNumber[2]) == 1:
            if x_ < r_[int(objRef.airfoil5DNumber[1] + objRef.airfoil5DNumber[2])]:
                yc_ = (
                    k1_
                    * (
                        pow(x_ - r_, 3)
                        - (k2k1_ * x_ * pow(1 - r_, 3))
                        - (x_ * pow(r_, 3))
                        + pow(r_, 3)
                    )
                ) / 6
                theta_ = math.degrees(
                    math.atan(
                        (
                            k1_
                            * (
                                (3 * pow(x_ - r_, 2))
                                - (k2k1_ * pow(1 - r_, 3))
                                - (pow(r_, 3))
                            )
                        )
                        / 6
                    )
                )
            else:
                yc_ = (
                    k1_
                    * (
                        (k2k1_ * pow(x_ - r_, 3))
                        - (k2k1_ * x_ * pow(1 - r_, 3))
                        - (x_ * pow(r_, 3))
                        + pow(r_, 3)
                    )
                ) / 6
                theta_ = math.degrees(
                    math.atan(
                        (
                            k1_
                            * (
                                (3 * k2k1_ * pow(x_ - r_, 2))
                                - (k2k1_ * pow(1 - r_, 3))
                                - (pow(r_, 3))
                            )
                        )
                        / 6
                    )
                )
        xu_.append((x_ - (yt_ * math.sin(math.radians(theta_)))) * chordLength_conv)
        yu_.append((yc_ + (yt_ * math.cos(math.radians(theta_)))) * chordLength_conv)
        xl_.append((x_ + (yt_ * math.sin(math.radians(theta_)))) * chordLength_conv)
        yl_.append((yc_ - (yt_ * math.cos(math.radians(theta_)))) * chordLength_conv)
        if objRef.progressBar_.value() < 50:
            objRef.progressBar_.setValue(round((i / (2 * n_)) * 100))
    xl_.reverse()
    yl_.reverse()
    objRef.pointsX, objRef.pointsY = xu_ + xl_, yu_ + yl_



def convTrig(mode, inputVal):
    if mode == 1:
        return math.sin(math.radians(inputVal))
    if mode == 2:
        return math.cos(math.radians(inputVal))
    if mode == 3:
        return math.tan(math.radians(inputVal))
    if mode == 4:
        return math.degrees(math.asin(inputVal))
    if mode == 5:
        return math.degrees(math.acos(inputVal))
    if mode == 6:
        return math.degrees(math.atan(inputVal))



def solveFx(f_, x_):
    f_ = f_.replace("x", "x_")
    f_ = f_.replace("^", "**")
    f_ = f_.replace("e", "math.e")
    f_ = f_.replace("pi", "math.pi")
    f_ = f_.replace("ln", "math.log")
    f_ = f_.replace("log", "math.log10")
    f_ = f_.replace("sqrt", "math.sqrt")
    f_ = f_.replace("sin(", "convTrig(1,")
    f_ = f_.replace("cos(", "convTrig(2,")
    f_ = f_.replace("tan(", "convTrig(3,")
    f_ = f_.replace("asin(", "convTrig(4,")
    f_ = f_.replace("acos(", "convTrig(5,")
    f_ = f_.replace("atan(", "convTrig(6,")
    try:
        return eval(f_)
    except Exception:
        return



def validateAirfoilNumber(objRef, digit):
    global NACA_5_2ND_3RD_DIGITS
    airfoilNumber = ""
    airfoilNumber = objRef.airfoil4DNumber if digit == 4 else objRef.airfoil5DNumber
    if airfoilNumber.isnumeric():
        if len(airfoilNumber) == digit:
            if int(airfoilNumber[-2:]) == 0:
                setAlertBox(
                    "The last two digits of the airfoil code cannot be a\nzero value !",
                    True,
                )
            else:
                if digit == 4:
                    return True
                elif digit == 5:
                    if int(airfoilNumber[0]) == 2:
                        if int(airfoilNumber[2]) <= 1:
                            for numRef in NACA_5_2ND_3RD_DIGITS:
                                if airfoilNumber[1] + airfoilNumber[2] == numRef:
                                    return True
                            if airfoilNumber[2] == 0:
                                setAlertBox(
                                    "The second digit of the airfoil code must be\nbetween one and five, both inclusive !",
                                    True,
                                )
                            elif airfoilNumber[2] == 1:
                                setAlertBox(
                                    "The second digit of the airfoil code must be\nbetween two and five, both inclusive !",
                                    True,
                                )
                        else:
                            setAlertBox(
                                "The third digit of the airfoil code must be either\na zero or a one !",
                                True,
                            )
                    else:
                        setAlertBox(
                            "The first digit of the airfoil code must be a two !", True
                        )
        else:
            setAlertBox(
                "Airfoil code must contain exactly " + digit + " digits !", True
            )
    else:
        setAlertBox("Airfoil code must be numeric !", True)
    objRef.airfoil4DNumber, objRef.airfoil5DNumber = "", ""
    return False



def validateFunction(objRef, mode):
    global FUNCTIONSARRAY
    function = [
        objRef.topCurveFunction.replace(" ", ""),
        objRef.bottomCurveFunction.replace(" ", ""),
    ]
    badFunctionCombinations = [
        "()",
        "(+",
        "(-",
        "(*",
        "(/",
        "(^",
        ")(",
        "+)",
        "-)",
        "*)",
        "/)",
        "^)",
        ".)",
        ").",
        ".(",
        "(.",
        "++",
        "--",
        "**",
        "//",
        "^^",
        "xx",
        "ee",
        "pipi",
        "xe",
        "ex",
        "xpi",
        "pix",
        "epi",
        "pie",
        "x(",
        "e(",
        "pi(",
        ")x",
        ")e",
        ")pi",
        ")ln",
        ")log",
        ")sqrt",
        ")sin",
        ")cos",
        ")tan",
        ")asin",
        ")acos",
        ")atan",
    ]
    modeName = ["Top", "Bottom"]
    for i in range(mode):
        if len(function[i]) > 0:
            if function[i].count("(") == function[i].count(")"):
                tempVar = function[i].replace(",", ".")
                for stringRef in FUNCTIONSARRAY:
                    tempVar = tempVar.replace(stringRef, "")
                if len(tempVar) == 0 or tempVar.isnumeric():
                    badFunction, badFunctionFound = "", False
                    for stringRef in badFunctionCombinations:
                        if function[i].count(stringRef) != 0:
                            badFunction, badFunctionFound = stringRef, True
                            break
                    if not badFunctionFound:
                        try:
                            if mode == 1:
                                if (
                                    solveFx(function[i], 0) >= 0
                                    and solveFx(function[i], 1) >= 0
                                ):
                                    return True
                                else:
                                    setAlertBox(
                                        "Top curve function 'range' should not be less than zero !",
                                        True,
                                    )
                            elif mode == 2 and i == 1:
                                if solveFx(function[i], 0) <= solveFx(
                                    function[i - 1], 0
                                ) and solveFx(function[i], 1) <= solveFx(
                                    function[i - 1], 1
                                ):
                                    return True
                                else:
                                    setAlertBox(
                                        "Top and Bottom curve function 'ranges' should not intersect!",
                                        True,
                                    )
                        except Exception:
                            setAlertBox(
                                modeName[i]
                                + " curve function contains unrecognizable,\ninvalid components !",
                                True,
                            )
                    else:
                        setAlertBox(
                            modeName[i]
                            + " curve function contains this invalidly\nwritten component ::  "
                            + badFunction,
                            True,
                        )
                else:
                    setAlertBox(
                        modeName[i]
                        + " curve function contains one or more\ninvalid, extraneous components !",
                        True,
                    )
            else:
                setAlertBox(
                    modeName[i] + " curve function contains unequal parantheses !", True
                )
        else:
            setAlertBox(modeName[i] + " curve function cannot be empty !", True)
    objRef.topCurveFunction, objRef.bottomCurveFunction = "", ""
    return False



def validateFile(objRef):
    global MIN_DATA_POINTS
    i_start, i_end, tempVar, tempStr, count, objRef.canMirror, x_prev, dir_ = (
        0,
        0,
        "",
        "",
        1,
        True,
        0,
        [1, 1],
    )
    i_start, i_end, fileReader_ = (
        (objRef.lineStart, objRef.lineEnd, objRef.loadedFile)
        if objRef.importFrom == 1
        else (objRef.row1, objRef.row2, csv.reader(objRef.loadedFile))
    )
    objRef.loadedFileContents = []
    if i_start == 0:
        i_start = i_end = 0
        for lineOrRow in fileReader_:
            if objRef.decimalType == 1:
                tempVar = lineOrRow
            elif objRef.decimalType == 2:
                tempVar = (
                    lineOrRow.replace(",", ".")
                    if objRef.importFrom == 1
                    else [element_.replace(",", ".") for element_ in lineOrRow]
                )
            pointsInLine = (
                re.findall(r"[+-]?\d+(?:\.\d+)?", tempVar)
                if objRef.importFrom == 1
                else re.findall(
                    r"[+-]?\d+(?:\.\d+)?",
                    tempVar[objRef.col1 - 1] + " " + tempVar[objRef.col2 - 1],
                )
            )
            if len(pointsInLine) == 2:
                i_start = count if i_start == 0 else i_start
                objRef.loadedFileContents.append(lineOrRow)
            else:
                if i_start != 0:
                    i_end = count - 1
                    break
            if i_start != 0:
                if tempStr == "":
                    tempStr = "1"
                elif tempStr == "1":
                    dir_[0] = dir_[1]
                    dir_[1] = (float(pointsInLine[0]) - x_prev) / abs(
                        float(pointsInLine[0]) - x_prev
                    )
                    if dir_[0] != dir_[1]:
                        objRef.canMirror = False
                        tempStr = "0"
                x_prev = float(pointsInLine[0])
            count += 1
        if i_start == 0:
            tempStr = (
                "File Line :: " + str(count)
                if objRef.importFrom == 1
                else "File Row :: " + str(count)
            )
            setAlertBox(
                "File is invalid, or file is of incorrect format !\n" + tempStr, True
            )
            return False
        elif i_end == 0:
            i_end = count - 1
            # return True
    else:
        for lineOrRow in fileReader_:
            if count >= i_start:
                if objRef.decimalType == 1:
                    tempVar = lineOrRow
                elif objRef.decimalType == 2:
                    tempVar = (
                        lineOrRow.replace(",", ".")
                        if objRef.importFrom == 1
                        else [element_.replace(",", ".") for element_ in lineOrRow]
                    )
                pointsInLine = (
                    re.findall(r"[+-]?\d+(?:\.\d+)?", tempVar)
                    if objRef.importFrom == 1
                    else re.findall(
                        r"[+-]?\d+(?:\.\d+)?",
                        tempVar[objRef.col1 - 1] + " " + tempVar[objRef.col2 - 1],
                    )
                )
                if len(pointsInLine) == 2:
                    objRef.loadedFileContents.append(lineOrRow)
                else:
                    if i_end == 0 and count != 1:
                        i_end = count
                        break
                    else:
                        tempStr = (
                            "File Line :: " + str(count)
                            if objRef.importFrom == 1
                            else "File Row :: " + str(count)
                        )
                        setAlertBox(
                            "File is invalid, or file is of incorrect format !\n"
                            + tempStr,
                            True,
                        )
                        return False
                if tempStr == "":
                    tempStr = "1"
                elif tempStr == "1":
                    dir_[0] = dir_[1]
                    dir_[1] = (float(pointsInLine[0]) - x_prev) / abs(
                        float(pointsInLine[0]) - x_prev
                    )
                    if dir_[0] != dir_[1]:
                        objRef.canMirror = False
                        tempStr = "0"
                x_prev = float(pointsInLine[0])
            count += 1
    # if i_end - i_start + 1 >= MIN_DATA_POINTS:
    # return True
    if i_end - i_start + 1 < MIN_DATA_POINTS:
        setAlertBox(
            "There must be a minimum of "
            + str(MIN_DATA_POINTS)
            + " selected file rows,\nthat is, pairs of data points !",
            True,
        )
        return False
    objRef.lineStart, objRef.row1, objRef.lineEnd, objRef.row2 = (
        (i_start, i_start, i_end, i_end)
        if objRef.importFrom == 1
        else (objRef.lineStart, objRef.row1, objRef.lineEnd, objRef.row2)
    )
    objRef.loadedFile.close()
    return True



######################################################################
###----------------------------------------------------------------###
### 		AEROFOIL MACRO CALLS - Bottom (check Top)	   ###
###----------------------------------------------------------------###
								   ###
if __name__ == "__main__":					   ###
    AeroFoilDialog()						   ###
								   ###
###----------------------------------------------------------------###
### 		AEROFOIL MACRO CALLS - Bottom (check Top)	   ###
###----------------------------------------------------------------###
######################################################################



